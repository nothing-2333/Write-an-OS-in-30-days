# 跟着敲系列
## 跟着《30天自制操作系统》（川合秀实 著）实现一个操作系统，使用NASM、GCC、Qemu等工具进行编译、运行。

## 代码部分参考的这个项目，大部分名字都沿用了，我实在不知道起什么名字好，另外这个项目作者太厉害了，在看他的代码的时候感觉学到了很多新的知识，除了一些已经熟练掌握部分复制了一下（应该只有1day那部分...），其他全部动手敲了一遍，另外在说明一点是，这个老项目在新版本中有些已经不能用了，我更新这些，有些地方在他原有的代码上做出了改进.共勉!
https://gitee.com/ghosind/HariboteOS/tree/main

## 有些命令怕忘记，写在这里了

sudo apt install qemu-system-x86

sudo make qemu

## 有些我在做这个新学到的知识也复制到这里
### Makefile 中 .PHONY
在 Makefile 中使用 .PHONY 声明的目标被视为“伪目标”，这意味着,总是执行命令 && 无视文件存在
### dd if=/dev/zero of=helloos.img bs=512 count=2880
命令 dd if=/dev/zero of=helloos.img bs=512 count=2880 使用了 dd 工具来创建一个磁盘镜像文件。下面是该命令各部分的详细说明：

dd：这是 Linux 和 Unix 系统中用于转换和复制文件的一个命令行工具，它特别适用于低级操作，比如从设备读取数据或向设备写数据。

if=/dev/zero：if 指定输入文件（input file）。/dev/zero 是一个特殊的字符设备文件，它提供无限的零（0）。当 dd 从 /dev/zero 读取时，它会得到一个无限的零流。

of=helloos.img：of 指定输出文件（output file）。在这个命令中，helloos.img 是将要创建的文件名，dd 将把从 /dev/zero 读取的数据写入这个文件。

bs=512：bs 代表块大小（block size）。这里设置为 512 字节，意味着 dd 在读取和写入数据时将以 512 字节为单位进行操作。这是磁盘扇区的标准大小，因此这个设置使得创建的镜像文件可以被当作磁盘扇区来处理。

count=2880：count 指定要复制的块的数量。这里设置为 2880，意味着 dd 将从 /dev/zero 读取 2880 个 512 字节的块，总共 1440000 字节（1.44 MB）。这个大小常用于模拟一个 1.44 MB 的软盘。
### dd 中 conv=notrunc 选项
conv=notrunc 是 dd 命令的一个转换（conv）选项，它告诉 dd 不要截断输出文件。换句话说，如果输出文件已经存在，dd 将不会将其大小缩减到指定的 count 和 bs（块大小）的乘积。相反，它会保留文件的原始大小，只在文件的开始处写入指定的数据。
### gdb 查看汇编指令 display /20i $pc display /20i 0x7c00
### 将显示的汇编指令转换为intel格式的汇编 set disassembly-flavor intel (默认是: set disassembly-flavor att )
### CYLS EQU 10
在汇编语言中，EQU 是一个伪指令，用于定义一个符号常量。EQU 指令将一个值或表达式与一个名称关联起来，这样在程序中就可以使用这个名称来代替实际的值。每次出现 cyls 时，汇编器都会将其替换为数值 10。
### Makefile语法部分不在赘述，自行查询
### [SECTION .btext]
这个指令是在一些汇编器（如 NASM）中使用的指令，用于定义一个新的代码段（section）名为 .btext。在汇编语言中，代码段是程序的一部分，其中包含可执行的代码。这个指令告诉汇编器，接下来的代码应该放在名为 .btext 的代码段中。
### [BITS 16]
这个指令用于设置汇编器的模式，告诉汇编器接下来的代码应该以16位模式编写。在x86架构中，[BITS 16] 指令通常用于指定实模式下的代码，这是大多数操作系统启动时使用的模式。这种模式下，CPU只能访问前1MB的内存，并且寄存器是16位宽的。
### objcopy
objcopy 是 GNU Binutils 工具集中的一个实用程序，主要用于复制和转换二进制目标文件。
### ndisasm haribote.sys
以查看处理过后的反汇编代码
### ALIGN 16
16 通常是一个伪指令，告诉汇编器将随后的代码或数据对齐到16字节边界。这可以通过添加填充字节（通常是0）来实现，以达到下一个16字节的边界。
### in ax, dx 
in ax, dx 这条指令的意思是将端口DX中的数据读入AX寄存器。
### out dx, al 
out dx, al 这条指令的意思是将AL寄存器中的数据发送到DX寄存器指定的端口
### pushfd
pushfd 是一个汇编指令，用于将32位的EFLAGS寄存器的内容压入栈顶。
### pushad 
pushad 是一个x86架构的汇编指令，用于将所有32位通用寄存器的值压入堆栈
### iretd
IRETD 是 x86 架构中的一条汇编指令，用于从中断或异常处理程序中返回到调用程序。

## 停更说明，好吧写到现在，越发觉得这次手写os的帮助甚微，我想我现在最需要的可能是在Android中实战，在真正的应用级os中学习，而不是重复做几个玩具